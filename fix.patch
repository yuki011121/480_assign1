diff --git a/planner.py b/planner.py
--- a/planner.py
+++ b/planner.py
@@ -0,0 +1,168 @@
+import sys
+import heapq
+
+def parse_world(filename):
+    """
+    读取 .txt 文件并返回网格、机器人起始位置和脏单元格位置列表。
+    """
+    with open(filename, 'r') as f:
+        lines = f.readlines()
+
+    cols = int(lines[0].strip())  # 第一行：列数
+    rows = int(lines[1].strip())  # 第二行：行数
+    
+    grid = [line.strip() for line in lines[2:]]
+    
+    robot_start = None
+    dirty_cells = []
+    
+    for r in range(rows):
+        for c in range(cols):
+            if grid[r][c] == '@':  # 机器人起始位置
+                robot_start = (r, c)
+            elif grid[r][c] == '*':  # 脏单元格
+                dirty_cells.append((r, c))
+                
+    return grid, robot_start, dirty_cells
+
+def generate_successors(state, grid):
+    """
+    根据当前状态生成所有可能的后继状态。
+    """
+    (row, col), dirty_cells = state
+    rows = len(grid)
+    cols = len(grid[0])
+    successors = []
+
+    # 1. 尝试移动动作 (N, S, E, W)
+    moves = {'N': (-1, 0), 'S': (1, 0), 'W': (0, -1), 'E': (0, 1)}
+    for action, (dr, dc) in moves.items():
+        new_row, new_col = row + dr, col + dc
+        
+        # 检查移动是否有效（在边界内且不是墙）
+        if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != '#':
+            new_state = ((new_row, new_col), dirty_cells)
+            successors.append((new_state, action))
+
+    # 2. 尝试吸尘动作 (V)
+    if (row, col) in dirty_cells:
+        new_dirty_cells = set(dirty_cells)
+        new_dirty_cells.remove((row, col))
+        new_state = ((row, col), frozenset(new_dirty_cells)) 
+        successors.append((new_state, 'V'))
+        
+    return successors
+
+def depth_first_search(grid, robot_start, dirty_cells):
+    """
+    执行深度优先搜索。
+    """
+    start_state = (robot_start, frozenset(dirty_cells))
+    frontier = [(start_state, [])]  # 使用列表作为栈
+    
+    visited = set()  # 用于避免循环
+    nodes_generated = 1
+    nodes_expanded = 0
+
+    while frontier:
+        current_state, path = frontier.pop()  # LIFO
+        
+        if current_state in visited:
+            continue
+        
+        nodes_expanded += 1
+        visited.add(current_state)
+
+        (pos, dirt) = current_state
+        if not dirt:  # 目标：没有剩余的脏单元格
+            return path, nodes_generated, nodes_expanded
+
+        successors = generate_successors(current_state, grid)
+        nodes_generated += len(successors)
+        
+        # 将后继节点逆序添加到frontier，可以模拟递归DFS的顺序
+        for new_state, action in reversed(successors):
+            if new_state not in visited:
+                new_path = path + [action]
+                frontier.append((new_state, new_path))
+                
+    return None, nodes_generated, nodes_expanded
+
+def uniform_cost_search(grid, robot_start, dirty_cells):
+    """
+    执行统一成本搜索。
+    """
+    start_state = (robot_start, frozenset(dirty_cells))
+    frontier = [(0, start_state, [])]  # (成本, 状态, 路径) 的优先队列
+    heapq.heapify(frontier)
+    
+    visited = set()
+    nodes_generated = 1
+    nodes_expanded = 0
+
+    while frontier:
+        cost, current_state, path = heapq.heappop(frontier)  # 弹出成本最低的节点
+        
+        if current_state in visited:
+            continue
+        
+        nodes_expanded += 1
+        visited.add(current_state)
+
+        (pos, dirt) = current_state
+        if not dirt:  # 目标：没有剩余的脏单元格
+            return path, nodes_generated, nodes_expanded
+
+        successors = generate_successors(current_state, grid)
+        nodes_generated += len(successors)
+
+        for new_state, action in successors:
+            if new_state not in visited:
+                new_cost = cost + 1  # 所有动作成本为1
+                new_path = path + [action]
+                heapq.heappush(frontier, (new_cost, new_state, new_path))
+
+    return None, nodes_generated, nodes_expanded
+
+def main():
+    """
+    主函数：解析参数，运行搜索并打印结果。
+    """
+    if len(sys.argv) != 3:
+        print("Usage: python3 planner.py [algorithm] [world-file]")
+        sys.exit(1)
+
+    algorithm = sys.argv[1].lower()
+    world_file = sys.argv[2]
+
+    try:
+        grid, robot_start, dirty_cells = parse_world(world_file)
+    except FileNotFoundError:
+        print(f"Error: World file not found at '{world_file}'")
+        sys.exit(1)
+
+    if robot_start is None:
+        print("Error: No robot start position '@' found in the world file.")
+        sys.exit(1)
+
+    if algorithm == "uniform-cost":
+        path, generated, expanded = uniform_cost_search(grid, robot_start, dirty_cells)
+    elif algorithm == "depth-first":
+        path, generated, expanded = depth_first_search(grid, robot_start, dirty_cells)
+    else:
+        print("Invalid algorithm. Choose 'uniform-cost' or 'depth-first'.")
+        sys.exit(1)
+
+    # 根据要求格式化输出
+    if path is not None:
+        for action in path:
+            print(action)  # 每行一个动作
+    else:
+        print("No solution found.")
+    
+    print(f"{generated} nodes generated")  # 打印生成的节点数
+    print(f"{expanded} nodes expanded")  # 打印扩展的节点数
+
+# 这是程序唯一的入口点
+if __name__ == "__main__":
+    main()